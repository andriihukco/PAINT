const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const colorPicker = document.getElementById('colorPicker');
const resolutionInput = document.getElementById('resolution');
const exportBtn = document.getElementById('exportBtn');

const gridSize = 10;
let brushColor = colorPicker.value;
let drawing = false;
let lastDrawnPixel = null;

// Save and Load from localStorage
const LOCAL_STORAGE_KEY = 'pixelArtCanvas';

// Draw grid
function drawGrid() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
    }
    for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
    }
    ctx.stroke();
}

// Draw pixel
function drawPixel(x, y) {
    ctx.fillStyle = brushColor;
    ctx.fillRect(x, y, gridSize, gridSize);
    saveCanvas();
}

// Get grid coordinates
function getGridCoordinates(event) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((event.clientX - rect.left) / gridSize) * gridSize;
    const y = Math.floor((event.clientY - rect.top) / gridSize) * gridSize;
    return { x, y };
}

// Draw straight line between two points
function drawLine(x0, y0, x1, y1) {
    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? gridSize : -gridSize;
    const sy = y0 < y1 ? gridSize : -gridSize;
    let err = dx - dy;

    while (true) {
        drawPixel(x0, y0);
        if (x0 === x1 && y0 === y1) break;
        const e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y0 += sy;
        }
    }
}

// Save canvas to localStorage
function saveCanvas() {
    const dataURL = canvas.toDataURL();
    localStorage.setItem(LOCAL_STORAGE_KEY, dataURL);
}

// Load canvas from localStorage
function loadCanvas() {
    const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
    if (savedData) {
        const img = new Image();
        img.onload = () => {
            ctx.drawImage(img, 0, 0);
        };
        img.src = savedData;
    }
}

// Event listeners
canvas.addEventListener('mousedown', (e) => {
    drawing = true;
    const { x, y } = getGridCoordinates(e);

    if (e.shiftKey && lastDrawnPixel) {
        drawLine(lastDrawnPixel.x, lastDrawnPixel.y, x, y);
    } else {
        drawPixel(x, y);
    }

    lastDrawnPixel = { x, y };
});

canvas.addEventListener('mousemove', (e) => {
    if (drawing) {
        const { x, y } = getGridCoordinates(e);
        drawPixel(x, y);
        lastDrawnPixel = { x, y };
    }
});

canvas.addEventListener('mouseup', () => {
    drawing = false;
});

canvas.addEventListener('click', (e) => {
    const { x, y } = getGridCoordinates(e);
    drawPixel(x, y);
});

// Update brush color
colorPicker.addEventListener('input', (e) => {
    brushColor = e.target.value;
});

// Export canvas
exportBtn.addEventListener('click', () => {
    const resolution = parseInt(resolutionInput.value);
    if (isNaN(resolution) || resolution < 10) {
        alert('Please enter a valid resolution.');
        return;
    }

    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');

    tempCanvas.width = resolution;
    tempCanvas.height = resolution;

    tempCtx.scale(resolution / canvas.width, resolution / canvas.height);
    tempCtx.drawImage(canvas, 0, 0);

    const link = document.createElement('a');
    link.href = tempCanvas.toDataURL('image/png');
    link.download = 'pixel-art.png';
    link.click();
});

// Initial setup
drawGrid();
loadCanvas();
